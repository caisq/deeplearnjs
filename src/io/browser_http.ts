/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

/**
 * IOHandler implementations based on HTTP requests in the web browser.
 *
 * Uses [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
 */

import {assert} from '../util';

import {getModelArtifactsInfoForKerasJSON} from './io_utils';
// tslint:disable-next-line:max-line-length
import {IOHandler, ModelArtifacts, SaveResult, WeightsManifestConfig} from './types';

export type RequestMethod = 'GET'|'POST'|'PUT'|'DELETE';
export type ExtraFormData = {
  // tslint:disable-next-line:no-any
  [key: string]: string
};

export interface BrowserHTTPRequestsConfig {
  method?: RequestMethod;
  extraFormData?: ExtraFormData;
}

export class BrowserHTTPRequest implements IOHandler {
  protected readonly path: string;
  protected readonly method: RequestMethod;
  protected readonly extraFormData: ExtraFormData;

  readonly DEFAULT_METHOD = 'POST';

  constructor(path: string, config?: BrowserHTTPRequestsConfig) {
    assert(
        path != null && path.length > 0,
        'URL path for browserHTTPRequest must not be null, undefined or ' +
            'empty.');
    this.path = path;
    this.method = (config == null || config.method == null) ?
        this.DEFAULT_METHOD :
        config.method;
    this.extraFormData = (config == null) ? null : config.extraFormData;
  }

  async save(modelArtifacts: ModelArtifacts): Promise<SaveResult> {
    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
      throw new Error(
          'HTTPReqwuests.save() does not support saving model topology ' +
          'in binary formats yet.');
    }

    return new Promise<SaveResult>(async (resolve, reject) => {
      const formData = new FormData();
      const weightsManifest: WeightsManifestConfig = [{
        paths: ['./model.weights.bin'],
        weights: modelArtifacts.weightSpecs,
      }];
      const modelTopologyAndWeightManifest = {
        modelTopology: modelArtifacts.modelTopology,
        weightsManifest
      };

      formData.append(
          'model.json',
          new Blob(
              [JSON.stringify(modelTopologyAndWeightManifest)],
              {type: 'application/json'}),
          'model.json');

      if (modelArtifacts.weightData != null) {
        formData.append(
            'model.weights.bin', new Blob([modelArtifacts.weightData], {
              type: 'application/octet-stream'
            }),
            'model.weights.bin');
      }

      // Append extra form data.
      if (this.extraFormData != null) {
        for (const key in this.extraFormData) {
          formData.append(key, this.extraFormData[key]);
        }
      }

      const response = await fetch(this.path, {
        method: this.method,
        body: formData,
      });

      if (response.status === 200) {
        resolve({
          modelArtifactsInfo: getModelArtifactsInfoForKerasJSON(modelArtifacts),
          responses: [response],
        });
      } else {
        reject(response);
      }
    });
  }

  // TODO(cais): Maybe add load to unify this IOHandler type and the mechanism
  //   that currently underlies `tf.loadModel('path')` in tfjs-layers.
}

// tslint:disable:max-line-length
/**
 * Creates an IOHandler subtype that sends model artifacts to HTTP server.
 *
 * An HTTP request of the `multipart/form-data` mime type will be sent to the
 * `path` URL. The form data includes artifacts that represent the topology
 * and/or weights of the model. In the case of Keras-style `tf.Model`, two
 * blobs (files) exist in form-data:
 *   - A JSON file consisting of `modelTopology` and `weightsManifest`.
 *   - A binary weights file consisting of the concatenated weight values.
 * These files are in the same format as the one generated by
 * [tensorflowjs_converter](https://js.tensorflow.org/tutorials/import-keras.html).
 *
 * The following code snippet exemplifies the client-side code that uses this
 * function:
 *
 * ```js
 * const model = tf.sequential();
 * model.add(
 *     tf.layers.dense({units: 1, inputShape: [100], activation: 'sigmoid'}));
 *
 * const saveResult = await model.save(tf.io.browserHTTPRequest(
 *     'http://model-server.domain:5000/upload'));
 * console.log(saveResult);
 * ```
 *
 * The following Python code snippet based on the
 * [flask](https://github.com/pallets/flask) server framework implements a
 * server that can receive the request. Upon receiving the model artifacrts
 * via the requst, this particular server writes them to files.
 *
 * ```python
 * # pip install flask flask-cors
 *
 * import os
 *
 * from flask import Flask, Response, request
 * from flask_cors import CORS, cross_origin
 * import werkzeug.formparser
 *
 *
 * class ModelWerkzeugFile:
 *   def __init__(self, filename):
 *     self.filepath = os.path.join('models', filename)
 *     if os.path.exists(self.filepath):
 *       os.remove(self.filepath)
 *
 *   def write(self, b):
 *     print('reading file parts of %s: size=%s' % (self.filepath, len(b)))
 *     with open(self.filepath, 'ab') as f:
 *       f.write(b)
 *
 *   def seek(self, *args, **kwargs):
 *     return 0
 *
 *
 * def stream_factory(total_content_length,
 *                    content_type,
 *                    filename,
 *                    content_length=None):
 *   return ModelWerkzeugFile(filename)
 *
 *
 * def main():
 *   app = Flask('model-server')
 *   cors = CORS(app)
 *   app.config['CORS_HEADER'] = 'Content-Type'
 *
 *   @app.route('/upload', methods=['POST'])
 *   @cross_origin()
 *   def upload():
 *     print('Handling request...')
 *     werkzeug.formparser.parse_form_data(
 *         request.environ, stream_factory=stream_factory)
 *     return Response(status=200)
 *
 *   app.run('localhost', 5000)
 *
 *
 * if __name__ == '__main__':
 *   main()
 * ```
 *
 * @param path URL path. Can be an absolute HTTP path (e.g.,
 *   'http://localhost:8000/model-upload)') or a relative path (e.g.,
 *   './model-upload').
 * @param config Additional options for the HTTP requests, including
 *   - method: HTTP request method (default: 'POST')
 *   - extraFormData: extra, non-file data to be included in the FormData of
 * the request.
 * @returns An instance of `BrowserHTTPRequest`.
 */
// tslint:enable:max-line-length
export function browserHTTPRequest(
    path: string, config?: BrowserHTTPRequestsConfig): BrowserHTTPRequest {
  return new BrowserHTTPRequest(path, config);
}
